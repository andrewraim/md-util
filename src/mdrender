#!/bin/bash

# TBD:
# - Use consistent capitalization

# Exit codes
EXIT_SUCCESS=0
EXIT_MISSING_MDFILE=255
EXIT_MISSING_FORMAT=254
EXIT_BAD_FORMAT=253
EXIT_PANDOC_ERROR=252
EXIT_BAD_CLEANUP=251
EXIT_BAD_OUTDIR=250
EXIT_NO_VIEWER=249
EXIT_BAD_VIEWER=248

PROGNAME=$(basename $0)
VERSION="0.1.0"

# Default path for temp materials. Use mktemp to find out where this is.
TEMP_DRYRUN=$(mktemp -u)
TEMP_BASE=$(dirname ${TEMP_DRYRUN})

# This is the location of pandoc template contents.
PANDOC_DIR=$HOME/.local/share/pandoc

# Default configuration path
CONFIG_PATH="./${PROGNAME}.conf"

print_help()
{
	echo "$PROGNAME $VERSION: Render a markdown document with Pandoc."
	echo ""
	echo "Formats:"
	print_formats ${CONFIG_PATH}
	echo ""

	cat <<- EOF
	Includes the following customizations for Pandoc:
	  - Use Pandoc config files from the folder $PANDOC_DIR
	  - Enable pandoc-citeproc for citations to references
	  - Enable hyperlinking of citations
	  - Give the references section a title

	Usage: $PROGNAME [OPTIONS] input

	OPTIONS:
	  -h	   Print this message and exit
	  -v       Print version and exit
	  -V	   Verbose: includes echoing Pandoc commands
	  -p	   Toggle preview (default: true in watch mode and false otherwise)
	  -f TYPE  Format: one of the format labels listed above
	  -t DIR   Base directory for temporary materials in watch mode
	           (default: ${TEMP_BASE}). When not in watch mode, output is
	           written to cwd.
	  -c PATH  Path to configuration file (default: ${CONFIG_PATH})
	  -w       Enable watch mode
	EOF
}

print_formats()
{
	local infile=$1
	local line section name

	while IFS= read -r line; do
		# Ignore comment lines
		if [[ "$line" =~ ^[[:space:]]*\# ]]; then
			continue
		fi

		# [section]
		if [[ "$line" =~ ^[[:space:]]*\[(.*)\][[:space:]]*$ ]]; then
			section="${BASH_REMATCH[1]}"
			continue
		fi

		# This line is relevant to the section. Process it.
		if [[ $line =~ ^[[:space:]]*desc[[:space:]]*=[[:space:]]*(.*)$ ]]; then
			value=${BASH_REMATCH[1]}
			echo "  - ${section}: ${value}"
		fi
	done < ${infile}

	# Output: FORMATS
}

## This function was adapted from a Reddit comment:
## https://www.reddit.com/r/bash/comments/s6crjo/comment/ht3vrh1
read_config()
{
	local infile=$1
	local section=$2
	local in_section=0
	local line name value

	while IFS= read -r line; do
		# Ignore comment lines
		if [[ "$line" =~ ^[[:space:]]*\# ]]; then
			continue
		fi

		# [section]
		if [[ "$line" =~ ^[[:space:]]*\[(.*)\][[:space:]]*$ ]]; then
			[[ "${BASH_REMATCH[1]}" == "$section" ]] && in_section=1 || in_section=0
			continue
		fi

		# If this was not a section marker, and we are not in the section of
		# interest, skip this line
		if ((!in_section)); then
			continue
		fi

		# This line is relevant to the section. Process it.
		if [[ $line =~ ^[[:space:]]*$ ]]; then
			# Ignore empty line
			# echo "E"
			continue
		elif [[ $line =~ ^[[:space:]]+(.*)$ ]]; then
			# Continuation of a previous line starts with indentation.
			# Use the same key from the last step and append the new material.
			# echo "C : $line"
			config[$name]="${config[$name]}$line"
		elif [[ $line =~ ^[[:space:]]*([^=]*)=[[:space:]]*(.*)$ ]]; then
			# New configuration item. Strip trailing whitespace from name
			name=${BASH_REMATCH[1]}
			name="${name%"${name##*[![:space:]]}"}"
			value=${BASH_REMATCH[2]}
			# echo "N : $name => $value"
			config[$name]="$value"
		fi

		# Need to read continuation lines (and maybe add backslash, or not have them)
	done < ${infile}
}

render()
{
	local mdpath=$1
	local outdir=$2
	local dest_ext=$3
	local pandoc_flags=$4
	local verbose=$5

	local src_ext=${mdpath##*.}
	local base=$(basename $mdpath)

	# name the output file
	if [ $base != $src_ext ]; then
		# replace extension of input file with "pdf"
		OUTFILE=${outdir}/${base%$src_ext}${dest_ext}
	else
		# there was no extension on input file, so add a ".pdf" to the output
		OUTFILE=${outdir}/${base}.${dest_ext}
	fi

	cmd="pandoc $mdpath $pandoc_flags -o $OUTFILE"

	# Echo the pandoc command if verbose option was enabled
	if [ $verbose == "true" ]; then
		echo $cmd
	fi

	eval $cmd || {
		exit ${EXIT_PANDOC_ERROR}
	}

	# Output: OUTFILE
}

preview()
{
	local infile=$1
	local viewer_cmd=$2
	local verbose=$3

	# Replace '%s' placeholder with filename
	viewer_cmd=${viewer_cmd//%s/$infile}

	# If not verbose, capture viewer output to /dev/null
	if [ $verbose == "false" ]; then
		viewer_cmd="${viewer_cmd} > /dev/null 2>&1"
	fi

	# Viewer should run as a detached process
	viewer_cmd="nohup ${viewer_cmd} &"

	eval ${viewer_cmd} || {
		echo "Viewer command failed: ${viewer_cmd}"
		exit ${EXIT_BAD_VIEWER}
	}
}

#-----------------------------
# ----- Begin processing -----
#-----------------------------
PREVIEW_TOGGLE=false
VERBOSE=false
WATCH_MODE=false

# ----- Get command line arguments -----

# Get the options
while getopts "hf:pt:c:wVv" option; do
	case $option in
		h)
			print_help
			exit ${EXIT_SUCCESS}
			;;
		c)
			CONFIG_PATH=${OPTARG}
			;;
		f)
			FORMAT=${OPTARG}
			;;
		p)
			PREVIEW_TOGGLE=true
			;;
		t)
			TEMP_BASE=${OPTARG}
			;;
		w)
			WATCH_MODE=true
			;;
		V)
			VERBOSE=true
			;;
		v)
			echo $VERSION
			exit ${EXIT_SUCCESS}
			;;
	esac
done

# Remaining argument should be the name of the markdown file for input
shift $(($OPTIND - 1))
MDFILE=$1

if [ -z "$MDFILE" ]; then
	echo "No input file specified"
	exit ${EXIT_MISSING_MDFILE}
fi

# Expand to absolute path
MDPATH=$(realpath $MDFILE)

# ----- Load configuration -----

# Read main config section and copy elements to array config_main
declare -A config=()
read_config ${CONFIG_PATH} "main"

declare -A config_main
for key in "${!config[@]}"; do
	config_main["$key"]="${config[$key]}"
done

# Check for default format in config if not specified on CLI
if [ -z "$FORMAT" ]; then
	if [ "${config_main["default"]}" != "" ]; then
		FORMAT=${config_main["default"]}
	else
		echo "No output format specified and no default set"
		exit ${EXIT_MISSING_FORMAT}
	fi
fi

# Read format config section and copy elements to array config_main
declare -A config=()
read_config ${CONFIG_PATH} ${FORMAT}

declare -A config_format
for key in "${!config[@]}"; do
	config_format["$key"]="${config[$key]}"
done

# TBD: handle if these are unspecified in config
DEST_EXT=${config_format["ext"]}
PANDOC_FLAGS="${config_main["flags"]} ${config_format["flags"]}"
INTERVAL_PEEK=${config_main["peek"]}
INTERVAL_REST=${config_main["rest"]}
VIEWER_CMD=${config_format["view"]}

# ----- Set up output for watch mode -----
# If watch mode is requested, output should go to a temporary area. Grab just
# the filename part of the path. Create a temp folder which is (almost) unique
# to the file's absolute path and the username. Otherwise output goes into cwd.
if [ $WATCH_MODE == "true" ]; then
	HASH=$(echo "${USER}-${MDPATH}" | md5sum - | cut -d' ' -f1 | cut -c1-8)
	OUTDIR="${TEMP_BASE}/${HASH}"
	mkdir -p ${OUTDIR} || {
		echo "Could not create directory ${OUTDIR}"
		exit ${EXIT_BAD_OUTDIR}
	}
	trap "rm -rf ${OUTDIR}" EXIT
else
	OUTDIR="${PWD}"
fi

# ----- Render -----
# Change to dirname of the input file so we can use its relative path to find
# bibliography and any other resouces.
cd $(dirname $MDPATH)
render ${MDPATH} ${OUTDIR} ${DEST_EXT} ${PANDOC_FLAGS} ${VERBOSE}

# ----- Preview -----
# Set preview mode based on watch interval and toggle it if requested
[[ $WATCH_MODE == "true" ]] && PREVIEW=true || PREVIEW=false

if [[ $PREVIEW_TOGGLE == "true" ]]; then
	[[ $PREVIEW == "true" ]] && PREVIEW=false || PREVIEW=true
fi

# Open previewer if the option was given.
if [ $PREVIEW == "true" ]; then
	preview "${OUTFILE}" "${VIEWER_CMD}" "${VERBOSE}"
fi

# ----- Watch for changes -----
if [ $WATCH_MODE == "false" ]; then
	exit ${EXIT_SUCCESS}
fi

THEN="$(stat -c "%Y" "${MDPATH}")"
while true; do
	sleep "$INTERVAL_PEEK"
	NOW="$(stat -c "%Y" "${MDPATH}")"

	if [[ "$NOW" != "$THEN" ]]; then
		[[ $VERBOSE == "true" ]] && echo "${MDFILE} was modified ${NOW}"
		render ${MDPATH} ${OUTDIR} ${DEST_EXT} ${PANDOC_FLAGS} ${VERBOSE}
		THEN="$NOW"
		sleep "$INTERVAL_REST"
	else
		[[ $VERBOSE == "true" ]] && echo "${MDFILE} not modified"
	fi
done

