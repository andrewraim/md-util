#!/bin/bash

# Exit codes
EXIT_SUCCESS=0
EXIT_MISSING_MDFILE=255
EXIT_MISSING_FORMAT=254
EXIT_BAD_FORMAT=253
EXIT_PANDOC_ERROR=252
EXIT_BAD_CLEANUP=251
EXIT_BAD_OUTDIR=250
EXIT_NO_VIEWER=249
EXIT_BAD_VIEWER=248

PROGNAME=$(basename $0)

# Default path for temp materials. Use mktemp to find out where this is.
TEMP_DRYRUN=$(mktemp -u)
TEMP_BASE=$(dirname ${TEMP_DRYRUN})

# This is the location of pandoc template contents.
PANDOC_DIR=$HOME/.local/share/pandoc

# Default configuration path
CONFIG_PATH="${PROGNAME}.conf"

print_help()
{
	cat <<- EOF
	$PROGNAME: Render a markdown document with Pandoc.

	Formats:
	  - note: PDF document suitable for informal documents.
	  - beamer: PDF slides using Beamer.
	  - html: Standalone HTML document.

	Includes the following customizations for Pandoc:
	  - Use Pandoc config files from the folder $PANDOC_DIR
	  - Enable pandoc-citeproc for citations to references
	  - Enable hyperlinking of citations
	  - Give the references section a title

	Usage: $PROGNAME [OPTIONS] input

	OPTIONS:
	  -h	   Print this message and exit
	  -v	   Verbose: echo Pandoc commands
	  -p	   Toggle preview (default: true in watch mode and false otherwise)
	  -f TYPE  Format: one of 'note', 'beamer', or 'html'
	  -t DIR   Base directory for temporary materials in watch mode (default:
		       ${TEMP_BASE}). When not in watch mode, output is written to cwd.
	  -w SEC   Watch source file (every SEC seconds) and re-render if changed
	  -c PATH  Path to configuration file (default: ${CONFIG_PATH})
	EOF
}

## Lightly adapted from:
## https://www.reddit.com/r/bash/comments/s6crjo/comment/ht3vrh1
read_config()
{
	local infile=$1
	local section=$2
	local in_section=0
	local line name value

	while IFS= read -r line; do
		# Ignore comment lines
		if [[ "$line" =~ ^[[:space:]]*\# ]]; then
			continue
		fi

		# [section]
		if [[ "$line" =~ ^[[:space:]]*\[(.*)\][[:space:]]*$ ]]; then
			[[ "${BASH_REMATCH[1]}" == "$section" ]] && in_section=1 || in_section=0
			continue
		fi

		# If this was not a section marker, and we are not in the section of
		# interest, skip this line
		if ((!in_section)); then
			continue
		fi

		# This line is relevant to the section. Process it.
		if [[ $line =~ ^[[:space:]]*$ ]]; then
			# Ignore empty line
			# echo "E"
			continue
		elif [[ $line =~ ^[[:space:]]+(.*)$ ]]; then
			# Continuation of a previous line starts with indentation.
			# Use the same key from the last step and append the new material.
			# echo "C : $line"
			config[$name]="${config[$name]}$line"
		elif [[ $line =~ ^[[:space:]]*([^=]*)[[:space:]]*=[[:space:]]*(.*)$ ]]; then
			# New configuration item
			name=${BASH_REMATCH[1]}
			value=${BASH_REMATCH[2]}
			# echo "N : $name => $value"
			config[$name]="$value"
		fi

		# Need to read continuation lines (and maybe add backslash, or not have them)
	done < ${infile}
}

render()
{
	local mdpath=$1
	local outdir=$2
	local format=$3
	local verbose=$4

	case ${format} in
		note)
			render_note_cmd ${mdpath} ${outdir}
			;;
		beamer)
			render_beamer_cmd ${mdpath} ${outdir}
			;;
		html)
			render_html_cmd ${mdpath} ${outdir}
			;;
		*)
			echo "Format ${format} not recognized"
			exit ${EXIT_BAD_FORMAT}
			;;
	esac

	# Echo the pandoc command if verbose option was enabled
	if [ $verbose == "true" ]; then
		echo $CMD
	fi

	eval $CMD || {
		exit ${EXIT_PANDOC_ERROR}
	}
}

render_note_cmd()
{
	local infile=$1
	local outdir=$2

	local ext=${infile##*.}
	local base=$(basename $infile)

	# Name the output file
	if [ $base != $ext ]; then
		# Replace extension of input file with "pdf"
		OUTFILE=${outdir}/${base%$ext}pdf
	else
		# There was no extension on input file, so add a ".pdf" to the output
		OUTFILE=${outdir}/${base}.pdf
	fi

	read -r -d '' CMD <<- EOM
	pandoc $infile \
	  --data-dir=$PANDOC_DIR \
	  --defaults=my-latex \
	  --citeproc \
	  --metadata link-citations=true \
	  --metadata reference-section-title=References \
	  -f markdown -t latex -s -o $OUTFILE
	EOM

	# Outputs: CMD, OUTFILE
}

render_beamer_cmd()
{
	local infile=$1
	local outdir=$2

	local ext=${infile##*.}
	local base=$(basename $infile)

	# Name the output file
	if [ $base != $ext ]; then
		# Replace extension of input file with "pdf"
		OUTFILE=${outdir}/${base%$ext}pdf
	else
		# There was no extension on input file, so add a ".pdf" to the output
		OUTFILE=${outdir}/${base}.pdf
	fi

	read -r -d '' CMD <<- EOM
	pandoc $infile \
	  --data-dir=$PANDOC_DIR \
	  --citeproc
	  --slide-level=2 \
	  --metadata link-citations=true \
	  --metadata reference-section-title=References \
	  -f markdown -t beamer -s -o $OUTFILE
	EOM

	# Outputs: CMD, OUTFILE
}

render_html_cmd()
{
	local infile=$1
	local outdir=$2

	local ext=${infile##*.}
	local base=$(basename $infile)

	# Name the output file
	if [ $base != $ext ]; then
		# Replace extension of input file with "html"
		OUTFILE=${outdir}/${base%$ext}html
	else
		# There was no extension on input file, so add a ".html" to the output
		OUTFILE=${outdir}/${base}.html
	fi

	read -r -d '' CMD <<- EOM
	pandoc $infile \
	  --data-dir=$PANDOC_DIR \
	  --citeproc
	  --metadata link-citations=true \
	  --metadata reference-section-title=References \
	  -f markdown -t html -s -o $OUTFILE
	EOM

	# Outputs: CMD, OUTFILE
}

preview()
{
	local file=$1
	local verbose=$2
	local ext=${file##*.}
	local detached=false

	case ${ext} in
		pdf)
			viewer_cmd="zathura ${file}"
			detached=true
			;;
		html)
			viewer_cmd="chromium ${file}"
			;;
		*)
			echo "No viewer defined for extension ${ext}"
			exit ${EXIT_NO_VIEWER}
			;;
	esac

	if [ $verbose == "false" ]; then
		viewer_cmd="${viewer_cmd} > /dev/null 2>&1"
	fi

	if [ $detached == "true" ]; then
		viewer_cmd="nohup ${viewer_cmd} &"
	fi

	eval ${viewer_cmd} || {
		echo "Viewer command failed: ${viewer_cmd}"
		exit ${EXIT_BAD_VIEWER}
	}
}

# ----- Begin Processing -----

PREVIEW_TOGGLE=false
VERBOSE=false

# Get the options
while getopts "hf:pt:w:c:v" option; do
	case $option in
		h)
			print_help
			exit ${EXIT_SUCCESS}
			;;
		c)
			CONFIG_PATH=${OPTARG}
			;;
		f)
			FORMAT=${OPTARG}
			;;
		p)
			PREVIEW_TOGGLE=true
			;;
		t)
			TEMP_BASE=${OPTARG}
			;;
		w)
			WATCH_INTERVAL=${OPTARG}
			;;
		v)
			VERBOSE=true
			;;
	esac
done

# Remaining argument should be the name of the markdown file for input
shift $(($OPTIND - 1))
MDFILE=$1

if [ -z "$MDFILE" ]; then
	echo "No input file specified"
	exit ${EXIT_MISSING_MDFILE}
fi

# Expand to absolute path
MDPATH=$(realpath $MDFILE)


# Read main config section and copy elements to array config_main
declare -A config=()
read_config ${CONFIG_PATH} "main"

declare -A config_main
for key in "${!config[@]}"; do
	config_main["$key"]="${config[$key]}"
done

# Read format config section and copy elements to array config_main
declare -A config=()
read_config ${CONFIG_PATH} ${FORMAT}

declare -A config_format
for key in "${!config[@]}"; do
	config_format["$key"]="${config[$key]}"
done

#echo
#echo "${config[@]}"
#echo "FLAGS?"
#flags=${config["flags"]}
#echo "$flags: $flags"
#echo "keys: ${!config[@]}"
#echo "values: ${config[@]}"
#echo
#echo "main keys: ${!config_main[@]}"
#echo "main values: ${config_main[@]}"
#echo
#echo "format keys: ${!config_format[@]}"
#echo "format values: ${config_format[@]}"
exit 0

# If watch mode is requested, output should go to a temporary area. Grab just
# the filename part of the path. Create a temp folder which is (almost) unique
# to the file's absolute path and the username.
#
# Otherwise output goes into cwd.
if [ -v WATCH_INTERVAL ]; then
	HASH=$(echo "${USER}-${MDPATH}" | md5sum - | cut -d' ' -f1 | cut -c1-8)
	OUTDIR="${TEMP_BASE}/${HASH}"
	mkdir -p ${OUTDIR} || {
		echo "Could not create directory ${OUTDIR}"
		exit ${EXIT_BAD_OUTDIR}
	}
	trap "rm -rf ${OUTDIR}" EXIT
else
	OUTDIR="${PWD}"
fi

if [ -z "$FORMAT" ]; then
	echo "No output format specified"
	exit ${EXIT_MISSING_FORMAT}
fi

# Change to dirname of the input file so we can use its relative path to find
# bibliography and any other resouces.
cd $(dirname $MDPATH)

render ${MDPATH} ${OUTDIR} ${FORMAT} ${VERBOSE}

# Set preview mode based on watch interval and toggle it if requested
[[ -v WATCH_INTERVAL ]] && PREVIEW=true || PREVIEW=false

if [[ $PREVIEW_TOGGLE == "true" ]]; then
	[[ $PREVIEW == "true" ]] && PREVIEW=false || PREVIEW=true
fi

# Open previewer if the option was given.
if [ $PREVIEW == "true" ]; then
	preview ${OUTFILE} ${VERBOSE}
fi

if [ -v WATCH_INTERVAL ]; then
	THEN="$(stat -c "%Y" "${MDPATH}")"
	while true; do
		sleep "$WATCH_INTERVAL"
		NOW="$(stat -c "%Y" "${MDPATH}")"

		if [[ "$NOW" != "$THEN" ]]; then
			[[ $VERBOSE == "true" ]] && echo "${MDFILE} was modified ${NOW}"
			render ${MDPATH} ${OUTDIR} ${FORMAT} ${VERBOSE}
			THEN="$NOW"
		else
			[[ $VERBOSE == "true" ]] && echo "${MDFILE} not modified"
		fi
	done
fi

